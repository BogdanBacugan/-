# Тема 11. Итераторы и генераторы
Отчет по Теме #11 выполнил:
- Ковех Екатерина
- ИВТ-22-1

| Задание | Лаб_раб | Сам_раб |
| - | - | - |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + |   |
| Задание 4 | + |   |
| Задание 5 | + |   |


# Лабараторные работы 
   ## Лабараторная работа 1

  ```python
nums = [0, 1, 2, 3, 4, 5]
for item in nums:
    print(item)

```
  ### Результат
  
 ![Меню](https://github.com/lEnityl/labs/blob/Tema_11/lab11/l1.png)

## Лабараторная работа 2

 ```python
class CountDown:
    def __init__(self, start):
        self.count = start + 1

    def __iter__(self):
        return self

    def __next__(self):
        self.count -= 1
        if self.count < 0:
            raise StopIteration
        return self.count


if __name__ == '__main__':
    counter = CountDown(5)
    for i in counter:
        print(i)

```

### Результат

![Меню](https://github.com/lEnityl/labs/blob/Tema_11/lab11/l2.png)

## Лабараторная работа 3

 ```python
a = [i ** 2 for i in range(1, 5)]

print("a - ", a)
for i in a:
    print(i)

print("iter(a) - ", iter(a))
for i in a:
    print(i)

```
### Результат

![Меню](https://github.com/lEnityl/labs/blob/Tema_11/lab11/l3.png)

## Лабараторная работа 4

 ```python
b = (i ** 2 for i in range(1, 5))
print(b)
for i in b:
    print(i)
print("second")


for i in b:
    print(i)

```
### Результат

![Меню](https://github.com/lEnityl/labs/blob/Tema_11/lab11/l4.png)

## Лабараторная работа 5

 ```python
def countdown(count):
    while count >= 0:
        yield count
        count -= 1


if __name__ == '__main__':
    counter = countdown(5)
    for i in counter:
        print(i)

```
### Результат

![Меню](https://github.com/lEnityl/labs/blob/Tema_11/lab11/l5.png)



# Самостоятельные работы

## Самостоятельная работа №1

  ```python
def fib(n):
    f_n, f_n1 = 1, 1
    for i in range(n):
        yield f_n
        f_n, f_n1 = f_n1, f_n1 + f_n


n = 321
f_list = list(fib(n))
print(f_list[-1])

```

### Результат

![Меню](https://github.com/lEnityl/labs/blob/Tema_11/lab11/s1.png)

## Краткий вывод:
Программа получает на вход номер числа Фибоначчи, после чего выводит это число на экран. Программа использует вместо оператора return, оператор yield, который превращает функцию в генератор, что позволяет существенно сократить затраты ресурсов. 
 
## Самостоятельная работа №2

 ```python
def fib(n):
    f_n, f_n1 = 1, 1
    with open("fib.txt", "w") as file:
        for i in range(n):
            file.write(f"{f_n}\n")
            yield f_n
            f_n, f_n1 = f_n1, f_n1 + f_n


n = 321
f_list = list(fib(n))
print(f_list[-1])

```

### Результат

![Меню](https://github.com/lEnityl/labs/blob/Tema_11/lab11/s2.png)


## Краткий вывод:
Программа работает по похожей логике, что и в первом задании, с 1 поправкой, полученные числа Фибоначчи записываются в файл построчно. Функция по прежнему получает на вход номер искомого числа, только теперь возвращаемый функцией результат необходимо получить, преобразуя его с помощью list(), после чего вывести результат в консоль.


# Общий вывод 
Итераторы и генераторы языка программирования Python играют ключевую роль в обработке последовательностей данных. Изучив их функциональность, можно сделать следующие выводы:

  1. Итерации по данным:
  Python предоставляет эффективные средства для итерации по последовательностям данных. Итераторы позволяют поочередно получать элементы, что упрощает обработку больших объемов информации.
  
  2. Генераторы для создания последовательностей:
  Генераторы представляют собой мощный инструмент для создания последовательностей данных на лету. Они позволяют генерировать значения по мере необходимости, что особенно полезно при работе с большими или бесконечными данными.
  
  3. Операции с итерируемыми объектами:
  Python предоставляет обширный набор функций для работы с итерируемыми объектами, такими как списки, кортежи и строки. Это включает в себя функции, такие как map(), filter(), и sorted(), которые позволяют эффективно обрабатывать и изменять данные.
  
  4. Гибкость при работе с данными:
  Итераторы и генераторы обеспечивают гибкость при обработке данных различных типов. Возможность создания собственных итераторов и генераторов позволяет легко адаптировать их под конкретные потребности задачи.
  
  5. Эффективность использования памяти:
  Генераторы отличаются от списков тем, что они не хранят все значения в памяти сразу. Это позволяет экономить ресурсы и обрабатывать данные по мере необходимости.

Итераторы и генераторы в Python предоставляют эффективные средства для обработки данных в различных сценариях, от простых задач до сложных алгоритмов. Понимание их работы является важным элементом в арсенале разработчика для эффективной работы с последовательностями.
